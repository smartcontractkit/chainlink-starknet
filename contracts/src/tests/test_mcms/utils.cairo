use core::integer::{u512, u256_wide_mul};
use alexandria_bytes::{Bytes, BytesTrait};
use alexandria_encoding::sol_abi::sol_bytes::SolBytesTrait;
use alexandria_encoding::sol_abi::encode::SolAbiEncodeTrait;
use alexandria_math::u512_arithmetics;
use core::math::{u256_mul_mod_n, u256_div_mod_n};
use core::zeroable::{IsZeroResult, NonZero, zero_based};
use alexandria_math::u512_arithmetics::{u512_add, u512_sub, U512Intou256X2,};

use starknet::{
    ContractAddress, EthAddress, EthAddressIntoFelt252, EthAddressZeroable, contract_address_const,
    eth_signature::public_key_point_to_eth_address,
    secp256_trait::{
        Secp256Trait, Secp256PointTrait, recover_public_key, is_signature_entry_valid, Signature,
        signature_from_vrs
    },
    secp256k1::{Secp256k1Point, Secp256k1Impl}, SyscallResult, SyscallResultTrait
};

use chainlink::mcms::{
    ExpiringRootAndOpCount, RootMetadata, Config, Signer, ManyChainMultiSig, Op,
    ManyChainMultiSig::{
        MANY_CHAIN_MULTI_SIG_DOMAIN_SEPARATOR_OP, MANY_CHAIN_MULTI_SIG_DOMAIN_SEPARATOR_METADATA,
        InternalFunctionsTrait, contract_state_for_testing, s_signersContractMemberStateTrait,
        s_expiring_root_and_op_countContractMemberStateTrait,
        s_root_metadataContractMemberStateTrait
    },
    IManyChainMultiSigDispatcher, IManyChainMultiSigDispatcherTrait,
    IManyChainMultiSigSafeDispatcher, IManyChainMultiSigSafeDispatcherTrait, IManyChainMultiSig,
    ManyChainMultiSig::{MAX_NUM_SIGNERS},
};

fn hash_op(op: Op) -> u256 {
    let mut encoded_leaf: Bytes = BytesTrait::new_empty()
        .encode(MANY_CHAIN_MULTI_SIG_DOMAIN_SEPARATOR_OP)
        .encode(op.chain_id)
        .encode(op.multisig)
        .encode(op.nonce)
        .encode(op.to)
        .encode(op.selector);
    // encode the data field by looping through
    let mut i = 0;
    while i < op.data.len() {
        encoded_leaf = encoded_leaf.encode(*op.data.at(i));
        i += 1;
    };
    encoded_leaf.keccak()
}

fn hash_metadata(metadata: RootMetadata, valid_until: u32) -> u256 {
    let encoded_metadata: Bytes = BytesTrait::new_empty()
        .encode(MANY_CHAIN_MULTI_SIG_DOMAIN_SEPARATOR_METADATA)
        .encode(valid_until)
        .encode(metadata.chain_id)
        .encode(metadata.multisig)
        .encode(metadata.pre_op_count)
        .encode(metadata.post_op_count)
        .encode(metadata.override_previous_root);

    encoded_metadata.keccak()
}

// efficient exponentiation
fn pow(base: u256, exponent: u256, modulo: u256) -> u256 {
    if exponent == 0 {
        0
    } else if exponent == 1 {
        base % modulo
    } else {
        let mut t = pow(base, exponent / 2, modulo);
        t = (t * t) % modulo;

        if exponent % 2 == 0 {
            t
        } else {
            ((base % modulo) * t) % modulo
        }
    }
}


impl U512PartialOrd of PartialOrd<u512> {
    #[inline(always)]
    fn le(lhs: u512, rhs: u512) -> bool {
        !(rhs < lhs)
    }
    #[inline(always)]
    fn ge(lhs: u512, rhs: u512) -> bool {
        !(lhs < rhs)
    }
    fn lt(lhs: u512, rhs: u512) -> bool {
        if lhs.limb3 < rhs.limb3 {
            true
        } else if lhs.limb3 == rhs.limb3 {
            if lhs.limb2 < rhs.limb2 {
                true
            } else if lhs.limb2 == rhs.limb2 {
                if lhs.limb1 < rhs.limb1 {
                    true
                } else {
                    false
                }
            } else {
                false
            }
        } else {
            false
        }
    }
    #[inline(always)]
    fn gt(lhs: u512, rhs: u512) -> bool {
        rhs < lhs
    }
}

//  *** THIS IS CRYPTOGRAPHICALLY INSECURE ***
// the usage of a constant random target means that anyone can reverse engineer the private keys
// therefore this method is only meant to be used for tests
// arg z: message hash, arg e: private key
fn insecure_sign(z: u256, e: u256) -> (u256, u256, bool) {
    let z_u512: u512 = u256_wide_mul(z, (0x1).into());

    // order of the finite group
    let N = Secp256k1Impl::get_curve_size().try_into().unwrap();
    let n_u512: u512 = u256_wide_mul(N, (0x1).into());

    // "random" number k would be generated by a pseudo-random number generator
    // in secure applications it's important that k is random, or else the private key can 
    // be derived from r and s
    let k = 777;

    // random target
    let R = Secp256k1Impl::get_generator_point().mul(k).unwrap();
    let (r_x, r_y) = R.get_coordinates().unwrap();

    // calculate s = ( z + r*e ) / k (finite element operations)
    // where product = r*e and sum = z + r*re
    let product = u256_mul_mod_n(r_x, e, N.try_into().unwrap());
    let product_u512: u512 = u256_wide_mul(product, (0x1).into());

    // sum = z + product (finite element operations)
    // avoid u256 overflow by casting to u512
    let mut sum_u512 = u512_add(z_u512, product_u512);
    while sum_u512 >= n_u512 {
        sum_u512 = u512_sub(sum_u512, n_u512);
    };
    let sum = sum_u512.try_into().unwrap();

    let s = u256_div_mod_n(sum, k, N.try_into().unwrap()).unwrap();

    let v = 27 + (r_y % 2);

    let y_parity = v % 2 == 0;

    (r_x, s, y_parity)
}

